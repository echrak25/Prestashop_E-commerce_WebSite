<?php
/**
 * Copyright since 2007 PrestaShop SA and Contributors
 * PrestaShop is an International Registered Trademark & Property of PrestaShop SA
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the Academic Free License version 3.0
 * that is bundled with this package in the file LICENSE.md.
 * It is also available through the world-wide-web at this URL:
 * https://opensource.org/licenses/AFL-3.0
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@prestashop.com so we can send you a copy immediately.
 *
 * @author    PrestaShop SA and Contributors <contact@prestashop.com>
 * @copyright Since 2007 PrestaShop SA and Contributors
 * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License version 3.0
 */

namespace WizardAI\ObjectModels;

if (!defined('_PS_VERSION_')) {
    exit;
}

use Category;
use CMS;
use ObjectModel;
use Product;
use Shop;
use WizardAI\WizardUI;

class WizardPrompt extends \ObjectModel
{
    /**
     * @var int
     */
    public $id_wizard_prompt;

    /**
     * @var string
     */
    public $name;

    /**
     * @var selector
     */
    public $selector;

    /**
     * @var string
     */
    public $action;

    /**
     * @var string
     */
    public $entity;

    /**
     * @var string
     */
    public $field;

    /**
     * @var string
     */
    public $conditions;

    /**
     * @var string
     */
    public $content;

    /**
     * @var bool
     */
    public $append_to_text;

    /**
     * @var bool
     */
    public $add_to_cron;

    /**
     * @var bool
     */
    public $translate_result;

    /**
     * @var bool
     */
    public $is_default;

    /**
     * @var bool
     */
    public $is_active;

    /**
     * @var int
     */
    public $id_shop;

    /**
     * @var string
     */
    public $label;

    /**
     * @var string
     */
    public $model;

    /**
     * @var float
     */
    public $temperature;

    /**
     * @var float
     */
    public $top_p;

    /**
     * @var float
     */
    public $repeat_penalty;

    /**
     * @var int
     */
    public $id_character;

    /**
     * @see ObjectModel::$definition
     */
    public static $definition = [
        'table' => 'wizard_prompts',
        'primary' => 'id_wizard_prompt',
        'multilang' => true,
        'fields' => [
            'name' => ['type' => self::TYPE_STRING, 'validate' => 'isString', 'required' => true],
            'selector' => ['type' => self::TYPE_STRING, 'validate' => 'isString', 'required' => true],
            'entity' => ['type' => self::TYPE_STRING, 'validate' => 'isString', 'required' => true],
            'field' => ['type' => self::TYPE_STRING, 'validate' => 'isString', 'required' => true],
            'conditions' => ['type' => self::TYPE_STRING],
            'content' => ['type' => self::TYPE_SQL, 'validate' => 'isCleanHtml', 'required' => true],
            'append_to_text' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],
            'add_to_cron' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],
            'translate_result' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],
            'is_default' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],
            'is_active' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],
            'id_shop' => ['type' => self::TYPE_INT, 'validate' => 'isUnsignedInt', 'required' => true],
            'label' => ['type' => self::TYPE_STRING, 'lang' => true, 'validate' => 'isGenericName', 'required' => true],
            'model' => ['type' => self::TYPE_STRING, 'validate' => 'isString'],
            'temperature' => ['type' => self::TYPE_FLOAT, 'validate' => 'isFloat'],
            'top_p' => ['type' => self::TYPE_FLOAT, 'validate' => 'isFloat'],
            'repeat_penalty' => ['type' => self::TYPE_FLOAT, 'validate' => 'isFloat'],
            'id_character' => ['type' => self::TYPE_INT, 'validate' => 'isUnsignedInt'],
        ],
    ];

    /**
     * WizardPrompt constructor.
     *
     * @param int|null $id
     * @param int|null $id_lang
     * @param int|null $id_shop
     * @param null $translator
     */
    public function __construct($id = null, $id_lang = null, $id_shop = null, $translator = null)
    {
        parent::__construct($id, $id_lang, $id_shop, $translator);
        $this->action = $this->selector;
    }

    public function save($null_values = false, $auto_date = true)
    {
        $this->selector = self::snake_case($this->name);

        return parent::save($null_values, $auto_date); // TODO: Change the autogenerated stub
    }

    /**
     * Get prompt by entity, field and shop ID.
     *
     * @param string $entity entity name
     * @param string $field field name
     * @param int $id_shop shop ID
     *
     * @return WizardPrompt|false prompt instance or false if not found
     */
    public static function getByEntityAndField($entity, $field, $id_shop)
    {
        $sql = new \DbQuery();
        $sql->select('*');
        $sql->from('wizard_prompts');
        $sql->where('`entity` = \'' . pSQL($entity) . '\'');
        $sql->where('`field` = \'' . pSQL($field) . '\'');
        $sql->where('`id_shop` = ' . (int) $id_shop);

        if ($row = \Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql)) {
            $prompt = new WizardPrompt();
            $prompt->hydrate($row);

            return $prompt;
        }

        return false;
    }

    /**
     * Get prompts by entity.
     *
     * @param string $entity entity name
     * @param int|null $id_entity entity ID
     * @param int|null $id_shop shop ID
     *
     * @return array array of prompts
     */
    public static function getPromptsByEntity($entity, $id_entity = null, $id_shop = null)
    {
        if ($id_shop === null) {
            $id_shop = \Context::getContext()->shop->id;
        }

        $sql = new \DbQuery();
        $sql->select('wp.*, wpl.`label`');
        $sql->from('wizard_prompts', 'wp');
        $sql->leftJoin('wizard_prompts_lang', 'wpl', 'wp.`id_wizard_prompt` = wpl.`id_wizard_prompt` AND wpl.`id_lang` = ' . (int) \Context::getContext()->language->id);
        $sql->where('`entity` = \'' . pSQL($entity) . '\'');
        $sql->where('`is_active` = 1');
        $sql->where('`id_shop` = ' . (int) $id_shop);

        $prompts = [];

        if ($rows = \Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($sql)) {
            foreach ($rows as $row) {
                $prompt = new WizardPrompt($row['id_wizard_prompt']);
                // Récupérer les catégories sélectionnées pour ce prompt
                $selected_categories = $prompt->getConditionFieldValue('categories');

                // Si un id_entity a été donné et que cette entité est une catégorie, vérifier si l'ID de l'entité est dans les catégories sélectionnées pour ce prompt
                if ($id_entity !== null && $entity === 'category' && in_array($id_entity, $selected_categories)) {
                    $prompts[] = $prompt;
                } // Si un id_entity a été donné et que cette entité est un produit, vérifier si le produit appartient à au moins une des catégories sélectionnées
                elseif ($id_entity !== null && $entity === 'product') {
                    $product = new \Product($id_entity);
                    $product_categories = $product->getCategories();

                    // Si le produit appartient à au moins une des catégories sélectionnées, ajouter le prompt
                    if (array_intersect($product_categories, $selected_categories)) {
                        $prompts[] = $prompt;
                    }
                } // Si aucune id_entity n'a été donnée ou si l'entité n'est pas une catégorie, ajouter le prompt sans vérifier les catégories sélectionnées
                elseif ($id_entity === null || $entity !== 'category') {
                    $prompts[] = $prompt;
                }
            }
        }

        return $prompts;
    }

    /**
     * Get prompts.
     *
     * @param array $filters
     *
     * @return array|false array of prompts or false if no prompts found
     */
    public static function getPrompts($filters = [])
    {
        $sql = new \DbQuery();
        $sql->select('wp.*, wpl.`label`');
        $sql->from('wizard_prompts', 'wp');
        $sql->leftJoin('wizard_prompts_lang', 'wpl', 'wp.`id_wizard_prompt` = wpl.`id_wizard_prompt` AND wpl.`id_lang` = ' . (int) \Context::getContext()->language->id);
        $sql->where('wp.`id_shop` = ' . (int) \Context::getContext()->shop->id);

        foreach ($filters as $key => $value) {
            if ($value !== '') {
                if ($key === 'order_by') {
                    continue;
                }
                $sql->where('wp.`' . pSQL($key) . '` LIKE \'%' . pSQL($value) . '%\'');
            }
        }

        if (!empty($filters['order_by'])) {
            $way = !empty($filters['order_way']) && in_array(strtolower($filters['order_way']), ['asc', 'desc']) ? $filters['order_way'] : 'asc';
            $sql->orderBy('`' . pSQL($filters['order_by']) . '` ' . $way);
        }

        $currentPage = max((int) \Tools::getValue('submitFilterwizard_prompts', 1), 1);
        $itemsPerPage = max((int) \Tools::getValue('wizard_prompts_pagination', 10), 1);
        $offset = ($currentPage - 1) * $itemsPerPage;
        // $sql->limit($itemsPerPage, $offset);

        $sql->groupBy('wp.id_wizard_prompt');

        try {
            $result = \Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($sql);
        } catch (Exception $e) {
            return [];
        }

        if (!is_array($result)) {
            return [];
        }

        $prompts = array_map(function ($row) {
            $prompt = new WizardPrompt();
            $prompt->hydrate($row);
            $character = new WizardCharacter($prompt->id_character);
            $prompt->character = $character;

            return $prompt;
        }, $result);

        return $prompts;
    }

    /**
     * Get all prompts for cron by entity
     *
     * @param string $entity
     * @param int|null $id_shop
     *
     * @return array|false
     */
    public static function getPromptsForCron($entity, $id_shop = null)
    {
        if ($id_shop === null) {
            $id_shop = \Context::getContext()->shop->id;
        }

        $sql = new \DbQuery();
        $sql->select('wp.*, wpl.`label`');
        $sql->from('wizard_prompts', 'wp');
        $sql->leftJoin('wizard_prompts_lang', 'wpl', 'wp.`id_wizard_prompt` = wpl.`id_wizard_prompt` AND wpl.`id_lang` = ' . (int) \Context::getContext()->language->id);
        $sql->where('`entity` = \'' . pSQL($entity) . '\'');
        $sql->where('`add_to_cron` = 1');
        $sql->where('`is_active` = 1');
        $sql->where('`id_shop` = ' . (int) $id_shop);

        $prompts = [];

        if ($rows = \Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS($sql)) {
            foreach ($rows as $row) {
                $prompt = new WizardPrompt($row['id_wizard_prompt']);
                $prompts[] = $prompt;
            }
        }

        return $prompts;
    }

    /**
     * Get the list of available entities for prompts.
     *
     * @return array array of entities
     */
    public static function getEntities()
    {
        $entities = [
            [
                'id' => 'product',
                'name' => 'Product',
            ],
            [
                'id' => 'category',
                'name' => 'Category',
            ],
            [
                'id' => 'supplier',
                'name' => 'Supplier',
            ],
            [
                'id' => 'manufacturer',
                'name' => 'Manufacturer',
            ],
            [
                'id' => 'cms',
                'name' => 'CMS Page',
            ],
            [
                'id' => 'cms_category',
                'name' => 'CMS Category',
            ],
            // Ajouter d'autres entités si nécessaire
        ];

        return $entities;
    }

    /**
     * Get the list of available entities for prompts.
     *
     * @return array array of entities
     */
    public static function getEntitiesPines($selectedEntity = null)
    {
        $entities = [
            [
                'value' => 'product',
                'title' => 'Product',
                'disabled' => false,
            ],
            [
                'value' => 'category',
                'title' => 'Category',
                'disabled' => false,
            ],
            [
                'value' => 'supplier',
                'title' => 'Supplier',
                'disabled' => false,
            ],
            [
                'value' => 'manufacturer',
                'title' => 'Manufacturer',
                'disabled' => false,
            ],
            [
                'value' => 'cms',
                'title' => 'CMS Page',
                'disabled' => false,
            ],
            [
                'value' => 'cms_category',
                'title' => 'CMS Category',
                'disabled' => false,
            ],
            // Ajouter d'autres entités si nécessaire
        ];

        if ($selectedEntity === null) {
            $selectedEntity = $entities[0];
        } else {
            foreach ($entities as $entity) {
                if ($entity['value'] === $selectedEntity) {
                    $selectedEntity = $entity;
                    break;
                }
            }
        }

        return [
            'selectedEntity' => json_encode($selectedEntity),
            'selectedEntities' => json_encode($entities),
        ];
    }

    /**
     * Get the list of fields for a given entity.
     *
     * @param string $entity le nom de l'entité
     *
     * @return array array of fields
     */
    public static function getPromptsFields($entity)
    {
        $fields = [];

        switch ($entity) {
            case 'product':
            case 'manufacturer':
                $fields = [
                    'description' => 'Description',
                    'short_description' => 'Short Description',
                    'meta_title' => 'Meta Title',
                    'meta_description' => 'Meta Description',
                    // Ajouter d'autres champs si nécessaire
                ];
                break;
            case 'supplier':
            case 'cms':
            case 'cms_category':
            case 'category':
                $fields = [
                    'description' => 'Description',
                    'meta_title' => 'Meta Title',
                    'meta_description' => 'Meta Description',
                    // Ajouter d'autres champs si nécessaire
                ];
                break;
                // Ajouter d'autres cas pour plus d'entités si nécessaire
        }

        $fields = array_map(function ($key, $value) {
            return [
                'id' => $key,
                'name' => $value,
            ];
        }, array_keys($fields), $fields);

        return $fields;
    }

    public static function getPromptsFieldsPines($entity, $selectedField = null)
    {
        $fields = [];

        switch ($entity) {
            case 'product':
            case 'manufacturer':
                $fields = [
                    [
                        'value' => 'description',
                        'title' => 'Description',
                        'disabled' => false,
                    ],
                    [
                        'value' => 'short_description',
                        'title' => 'Short Description',
                        'disabled' => false,
                    ],
                    [
                        'value' => 'meta_title',
                        'title' => 'Meta Title',
                        'disabled' => false,
                    ],
                    [
                        'value' => 'meta_description',
                        'title' => 'Meta Description',
                        'disabled' => false,
                    ],
                    // Ajouter d'autres champs si nécessaire
                ];
                break;
            case 'supplier':
            case 'cms':
            case 'cms_category':
            case 'category':
                $fields = [
                    [
                        'value' => 'description',
                        'title' => 'Description',
                        'disabled' => false,
                    ],
                    [
                        'value' => 'meta_title',
                        'title' => 'Meta Title',
                        'disabled' => false,
                    ],
                    [
                        'value' => 'meta_description',
                        'title' => 'Meta Description',
                        'disabled' => false,
                    ],
                    // Ajouter d'autres champs si nécessaire
                ];
                break;
                // Ajouter d'autres cas pour plus d'entités si nécessaire
        }

        if ($selectedField === null) {
            $selectedField = $fields[0];
        } else {
            foreach ($fields as $field) {
                if ($field['value'] === $selectedField) {
                    $selectedField = $field;
                    break;
                }
            }
        }

        return [
            'selectedField' . ucfirst($entity) => json_encode($selectedField),
            'selectedFields' . ucfirst($entity) => json_encode($fields),
        ];
    }

    /**
     * Convert a string to snake_case.
     *
     * @param string $str la chaîne à convertir
     *
     * @return string la chaîne convertie en snake_case
     */
    public static function snake_case($str)
    {
        $str = preg_replace('/[^a-zA-Z0-9]/', '_', $str); // Remplacer les caractères spéciaux par des underscores
        $str = preg_replace('/(?<=\\w)(?=[A-Z])/', '_$1', $str); // Ajouter des underscores entre les mots

        return strtolower($str); // Convertir en minuscules
    }

    /**
     * Get a prompt by its action.
     *
     * @param string $action L'action de la prompt
     *
     * @return WizardPrompt|null la prompt correspondante ou null si aucune prompt n'est trouvée
     */
    public static function getPromptByAction($action, $id_shop = null)
    {
        $prompts = self::getPrompts();

        foreach ($prompts as $prompt) {
            if ($prompt->selector === $action) {
                return new WizardPrompt($prompt->id, null, $id_shop);
            }
        }

        return null;
    }

    /**
     * Get empty prompt class
     */
    public static function getEmptyPrompt()
    {
        $prompt = new WizardPrompt();
        $prompt->id_shop = \Context::getContext()->shop->id;
        $prompt->content = [''];
        $prompt->is_active = true;
        $prompt->is_default = false;
        $prompt->translate_result = false;
        $prompt->append_to_text = false;
        $prompt->add_to_cron = true;
        $prompt->model = 'gpt-3.5-turbo';
        $prompt->temperature = 0.5;
        $prompt->top_p = 1;
        $prompt->repeat_penalty = 0.5;
        $prompt->id_character = 1;

        return $prompt;
    }

    /**
     * Convert the object to an array.
     *
     * @return array the object as an array
     */
    public function toArray()
    {
        $array = [
            'id_wizard_prompt' => $this->id,
            'name' => $this->name,
            'entity' => $this->entity,
            'field' => $this->field,
            'conditions' => $this->conditions,
            'categories' => $this->getConditionFieldValue('categories'),
            'content' => $this->content,
            'append_to_text' => $this->append_to_text,
            'translate_result' => $this->translate_result,
            'add_to_cron' => $this->add_to_cron,
            'is_default' => $this->is_default,
            'is_active' => $this->is_active,
            'label' => $this->label,
            'model' => $this->model,
            'temperature' => $this->temperature,
            'top_p' => $this->top_p,
            'repeat_penalty' => $this->repeat_penalty,
            'id_character' => $this->id_character,
        ];

        return $array;
    }

    /**
     * Get the total number of prompts.
     *
     * @return int the total number of prompts
     */
    public static function getTotalPrompts()
    {
        $sql = new \DbQuery();
        $sql->select('COUNT(*)');
        $sql->from('wizard_prompts');
        $sql->where('`id_shop` = ' . (int) \Context::getContext()->shop->id);

        return \Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($sql);
    }

    /**
     * Ajoute un champ et sa valeur aux conditions au format JSON.
     *
     * @param string $fieldName le nom du champ à ajouter
     * @param mixed $fieldValue la valeur du champ à ajouter
     *
     * @return bool retourne vrai si le champ a été ajouté avec succès, sinon faux
     */
    public function addConditionField($fieldName, $fieldValue)
    {
        // Récupère les conditions actuelles de la prompt
        $conditions = json_decode($this->conditions, true);

        // Ajoute le nouveau champ et sa valeur aux conditions
        $conditions[$fieldName] = $fieldValue;

        // Met à jour la propriété conditions de la prompt
        $this->conditions = json_encode($conditions);
    }

    /**
     * Récupère tous les champs dans la propriété conditions.
     *
     * @return array un tableau associatif contenant tous les champs et leurs valeurs dans les conditions
     */
    public function getAllConditionFields()
    {
        // Récupère les conditions actuelles de la prompt
        $conditions = json_decode($this->conditions, true);

        // Retourne le tableau des champs et de leurs valeurs dans les conditions
        return $conditions;
    }

    /**
     * Récupère la valeur d'un champ spécifique dans la propriété conditions.
     *
     * @param string $fieldName le nom du champ à récupérer
     *
     * @return mixed la valeur du champ spécifié, ou null si le champ n'est pas trouvé dans les conditions
     */
    public function getConditionFieldValue($fieldName)
    {
        // Récupère les conditions actuelles de la prompt
        $conditions = json_decode($this->conditions, true);

        // Retourne la valeur du champ spécifié, ou null si le champ n'est pas trouvé dans les conditions
        return isset($conditions[$fieldName]) ? $conditions[$fieldName] : null;
    }

    /**
     * Compile le contenu de la prompt en remplaçant les variables par les valeurs correspondantes.
     *
     * @param $prompt L'objet prompt à compiler
     * @param string $entity L'entité de la prompt (product, category, cms, cms_category)
     * @param int $entityId L'ID de l'entité
     * @param string $locale la langue locale (ex: "fr", "gb")
     *
     * @return string le contenu de la prompt compilé
     *
     * @throws \Exception en cas d'erreur lors de la récupération des données
     */
    public static function compilePromptContent($prompt, $entity, $entityId, $locale)
    {
        $content = $prompt->getContent();
        $contentCompiled = [];

        foreach ($content as &$contentItem) {
            // Charger l'objet langue
            $language = new \Language(\Language::getIdByIso($locale));
            $contentItem = self::replaceObjectProperties($contentItem, $language);

            // Charger l'objet boutique
            $shop = new \Shop(\Context::getContext()->shop->id);
            $contentItem = self::replaceObjectProperties($contentItem, $shop);

            // replace {{value}} by $value
            // $content = str_replace('{{value}}', $value, $content);

            switch ($entity) {
                case 'product':
                    // Charger l'objet produit
                    $product = new \Product($entityId, false, $language->id);
                    // Remplacer les variables spécifiques au produit
                    $contentItem = self::replaceObjectProperties($contentItem, $product);
                    break;

                case 'category':
                    // Charger l'objet catégorie
                    $category = new \Category($entityId, $language->id);
                    // Remplacer les variables spécifiques à la catégorie
                    $contentItem = self::replaceObjectProperties($contentItem, $category);
                    break;

                case 'cms':
                    // Charger l'objet page CMS
                    $cms = new \CMS($entityId, $language->id);

                    // Remplacer les variables spécifiques à la page CMS
                    $contentItem = self::replaceObjectProperties($contentItem, $cms);
                    break;

                case 'cms_category':
                    // Charger l'objet catégorie de CMS
                    $cmsCategory = new \CMSCategory($entityId, $language->id);
                    // Remplacer les variables spécifiques à la catégorie de CMS
                    $contentItem = self::replaceObjectProperties($contentItem, $cmsCategory);
                    break;

                case 'manufacturer':
                    // Charger l'objet catégorie de CMS
                    $manufacturer = new \Manufacturer($entityId, $language->id);
                    // Remplacer les variables spécifiques à la catégorie de CMS
                    $contentItem = self::replaceObjectProperties($contentItem, $manufacturer);
                    break;

                case 'supplier':
                    // Charger l'objet catégorie de CMS
                    $supplier = new \Supplier($entityId, $language->id);
                    // Remplacer les variables spécifiques à la catégorie de CMS
                    $contentItem = self::replaceObjectProperties($contentItem, $supplier);
                    break;

                default:
                    throw new \Exception("Entité non prise en charge : $entity");
            }
            $contentCompiled[] = $contentItem;
        }

        return $contentCompiled;
    }

    /**
     * Remplace les propriétés de l'entité dans le contenu de la prompt.
     *
     * @param string $content le contenu de la prompt
     * @param object $entity L'objet de l'entité (produit, catégorie)
     *
     * @return string le contenu de la prompt avec les propriétés de l'entité remplacées
     */
    /**
     * Remplace les propriétés de l'entité dans le contenu de la prompt.
     *
     * @param string $content le contenu de la prompt
     * @param object $entity L'objet de l'entité (produit, catégorie)
     *
     * @return string le contenu de la prompt avec les propriétés de l'entité remplacées
     */
    private static function replaceObjectProperties($content, $object)
    {
        // Traitement des conditions {% if ... %}
        $content = self::processConditionTags($content, $object);

        preg_match_all('/{{\w+\.\w+}}/', $content, $matches);

        foreach ($matches[0] as $match) {
            $property = substr($match, 2, -2); // Supprimer les accolades
            $propertyParts = explode('.', $property);
            switch ($propertyParts[0]) {
                case 'product':
                    $propertyParts[0] = 'Product';
                    break;
                case 'category':
                    $propertyParts[0] = 'Category';
                    break;
                case 'cms':
                    $propertyParts[0] = 'CMS';
                    break;
                case 'cms_category':
                    $propertyParts[0] = 'CMSCategory';
                    break;
                case 'manufacturer':
                    $propertyParts[0] = 'Manufacturer';
                    break;
                case 'supplier':
                    $propertyParts[0] = 'Supplier';
                    break;
                case 'language':
                    $propertyParts[0] = 'Language';
                    break;
                case 'shop':
                    $propertyParts[0] = 'Shop';
                    break;
            }
            // Vérifier si la propriété existe dans l'objet et correspond à l'entité en cours
            if (count($propertyParts) > 1 && $propertyParts[0] === get_class($object)) {
                $propertyName = $propertyParts[1];

                // Vérifier si la propriété existe dans l'objet
                if (property_exists($object, $propertyName)) {
                    $propertyValue = $object->{$propertyName};

                    if ($propertyName == 'category') {
                        $features = self::getProductMainCategory($object, $object->id_lang);
                        $content = str_replace($match, $features, $content);
                    }
                    // Si la propriété a plusieurs niveaux d'accès (ex: product.name)
                    if (count($propertyParts) > 2 && is_object($propertyValue)) {
                        $propertyValue = self::getPropertyValue($propertyValue, array_slice($propertyParts, 2));
                    }

                    $content = str_replace($match, $propertyValue, $content);
                }

                // if $propertyName is features ( error )
                if ($propertyName == 'features') {
                    $features = self::getProductFeatures($object, $object->id_lang);
                    $content = str_replace($match, $features, $content);
                }

                if ($propertyName == 'attributes') {
                    $attributes = self::getProductAttributesList($object, $object->id_lang);
                    $content = str_replace($match, $attributes, $content);
                }

                if ($propertyName == 'category_url') {
                    $category_url = self::getProductCategoryUrl($object, $object->id_lang);
                    $content = str_replace($match, $category_url, $content);
                }

                if ($propertyName == 'manufacturer') {
                    $manufacturer = $object->getWsManufacturerName();
                    $content = str_replace($match, $manufacturer, $content);
                }

                if ($propertyName == 'parents_categories') {
                    $categories = self::getParentCategories($object, $object->id_lang);
                    $content = str_replace($match, $categories, $content);
                }
            }
        }

        return $content;
    }

    private static function processConditionTags($content, $object)
    {
        // Trouver tous les blocs de conditions {% if ... %} ... {% endif %}
        preg_match_all('/{%\s*if\s+(\w+\.\w+)\s*%}(.*?){%\s*endif\s*%}/s', $content, $matches);

        foreach ($matches[0] as $index => $match) {
            $property = $matches[1][$index];
            $innerContent = $matches[2][$index];

            $propertyParts = explode('.', $property);

            // Convertir les parties de la propriété en classes appropriées
            switch ($propertyParts[0]) {
                case 'product':
                    $propertyParts[0] = 'Product';
                    break;
                case 'category':
                    $propertyParts[0] = 'Category';
                    break;
                case 'cms':
                    $propertyParts[0] = 'CMS';
                    break;
                case 'cms_category':
                    $propertyParts[0] = 'CMSCategory';
                    break;
                case 'language':
                    $propertyParts[0] = 'Language';
                    break;
                case 'shop':
                    $propertyParts[0] = 'Shop';
                    break;
            }

            if (count($propertyParts) > 1 && $propertyParts[0] === get_class($object)) {
                $propertyName = $propertyParts[1];

                // Si la propriété existe dans l'objet
                if (property_exists($object, $propertyName)) {
                    $propertyValue = $object->{$propertyName};
                    // Si la propriété est non vide (ou non nulle), on remplace le bloc de condition entier
                    // par son contenu interne. Sinon, on le supprime.
                    if (!empty($propertyValue)) {
                        $content = str_replace($match, $innerContent, $content);
                    } else {
                        $content = str_replace($match, '', $content);
                    }
                } elseif ($propertyName == 'features') {
                    $features = self::getProductFeatures($object, $object->id_lang);
                    if (!empty($features)) {
                        $content = str_replace($match, $innerContent, $content);
                    } else {
                        $content = str_replace($match, '', $content);
                    }
                } elseif ($propertyName == 'attributes') {
                    $attributes = self::getProductAttributesList($object, $object->id_lang);
                    if (!empty($attributes)) {
                        $content = str_replace($match, $innerContent, $content);
                    } else {
                        $content = str_replace($match, '', $content);
                    }
                } elseif ($propertyName == 'manufacturer') {
                    $manufacturer = $object->getWsManufacturerName();
                    if (!empty($manufacturer)) {
                        $content = str_replace($match, $innerContent, $content);
                    } else {
                        $content = str_replace($match, '', $content);
                    }
                } elseif ($propertyName == 'category_url') {
                    $category_url = self::getProductCategoryUrl($object, $object->id_lang);
                    if (!empty($category_url)) {
                        $content = str_replace($match, $innerContent, $content);
                    } else {
                        $content = str_replace($match, '', $content);
                    }
                } elseif ($propertyName == 'parents_categories') {
                    $categories = self::getParentCategories($object, $object->id_lang);
                    if (!empty($categories)) {
                        $content = str_replace($match, $innerContent, $content);
                    } else {
                        $content = str_replace($match, '', $content);
                    }
                } else {
                    // Si la propriété n'existe pas, supprimer le bloc de condition
                    $content = str_replace($match, '', $content);
                }
            }
        }

        return $content;
    }

    /**
     * Récupère la valeur d'une propriété à plusieurs niveaux d'accès dans l'objet.
     *
     * @param object $object L'objet contenant la propriété
     * @param array $propertyParts les parties de la propriété
     *
     * @return mixed la valeur de la propriété
     */
    private static function getPropertyValue($object, array $propertyParts)
    {
        $propertyValue = $object;
        foreach ($propertyParts as $part) {
            if (is_object($propertyValue) && property_exists($propertyValue, $part)) {
                $propertyValue = $propertyValue->{$part};
            } else {
                return null; // La propriété n'existe pas, retourner null
            }
        }

        return $propertyValue;
    }

    /**
     * Récupère les caractéristiques d'un produit sous forme de texte.
     *
     * @param \Product $product L'objet produit
     * @param int $id_lang L'ID de la langue
     *
     * @return string les caractéristiques du produit
     */
    public static function getProductFeatures(\Product $product, $id_lang)
    {
        $features = '';

        $featuresArray = array_unique($product->getFrontFeatures($id_lang), SORT_REGULAR);

        foreach ($featuresArray as $feature) {
            $features .= $feature['name'] . ': ' . $feature['value'] . ', ';
        }

        // Supprimer la virgule et l'espace en fin de chaîne
        $features = rtrim($features, ', ');

        return $features;
    }

    public static function getProductAttributesList($product, $id_lang)
    {
        // Récupérer les déclinaisons du produit
        $combinations = $product->getAttributeCombinations($id_lang);

        // Préparer un tableau pour organiser les attributs
        $attributes = [];

        // Organiser les attributs par groupe
        foreach ($combinations as $combination) {
            $groupName = $combination['group_name'];
            $attributeName = $combination['attribute_name'];

            // Si le groupe n'existe pas encore, le créer
            if (!isset($attributes[$groupName])) {
                $attributes[$groupName] = [];
            }

            // Ajouter l'attribut au groupe s'il n'est pas déjà présent
            if (!in_array($attributeName, $attributes[$groupName])) {
                $attributes[$groupName][] = $attributeName;
            }
        }

        // Construire la chaîne de caractères de sortie
        $output = [];
        foreach ($attributes as $groupName => $attributeNames) {
            $output[] = $groupName . ' : ' . implode(', ', $attributeNames);
        }

        return implode(', ', $output);
    }

    public static function getProductCategoryUrl($product, $id_lang)
    {
        $category = new \Category($product->id_category_default, $id_lang);
        $link = new \Link();
        $category_url = $link->getCategoryLink($category->id_category, $category->link_rewrite, $id_lang);

        return $category_url;
    }

    /**
     * Récupère la catégorie par défaut d'un produit sous forme de texte.
     *
     * @param \Product $product L'objet produit
     *
     * @return string la catégorie principale du produit
     */
    private static function getProductMainCategory(\Product $product, $id_lang)
    {
        $category = new \Category($product->id_category_default, $id_lang);

        return $category->name;
    }

    /**
     * Obtient les catégories parentes d'une catégorie.
     *
     * @param \Category $category L'objet de la catégorie
     *
     * @return string les catégories parentes séparées par une virgule
     */
    public static function getParentCategories(\Category $category, $id_lang)
    {
        $parentsCategories = $category->getParentsCategories($id_lang);
        $categoryNames = [];

        foreach ($parentsCategories as $parentCategory) {
            // Exclure la catégorie d'accueil (Home/Accueil) et la catégorie courante
            if ($parentCategory['id_category'] != 2 && $parentCategory['id_category'] != $category->id) {
                $categoryNames[] = $parentCategory['name'];
            }
        }

        return implode(', ', $categoryNames);
    }

    /**
     * Get  prompt by Id Entity, id_lang and id_shop with sql request
     *
     * @param $entity
     * @param $entityId
     * @param $idLang
     * @param $idShop
     *
     * @return WizardPrompt|false
     */
    public static function getPromptByEntity($selector, $entity, $idLang, $idShop)
    {
        $sql = new \DbQuery();
        $sql->select('*');
        $sql->from('wizard_prompts');
        $sql->where('entity = "' . pSQL($entity) . '"');
        $sql->where('selector = "' . pSQL($selector) . '"');
        $sql->where('id_shop = ' . (int) $idShop);

        $result = \Db::getInstance()->getRow($sql);

        if ($result) {
            $prompt = new WizardPrompt($result['id_wizard_prompt'], $idLang, $idShop);

            return $prompt;
        } else {
            return false;
        }
    }

    /**
     * Get all prompts by Id Entity, id_lang and id_shop with sql request
     *
     * @param $Ids
     *
     * @return void
     *
     * @throws \PrestaShopDatabaseException
     * @throws \PrestaShopException
     */
    public static function activeAllCategoriesByIdsPrompt($Ids)
    {
        // 1. Récupérer toutes les catégories
        $categories = \Category::getSimpleCategories(\Context::getContext()->language->id);

        // 2. Récupérer les IDs de toutes les catégories
        $categoryIds = [];

        foreach ($categories as $category) {
            $categoryIds[] = $category['id_category'];
        }

        // 3. Activer toutes les catégories pour chaque prompt
        foreach ($Ids as $id) {
            $wizardPrompt = new WizardPrompt((int) $id);
            $wizardPrompt->addConditionField('categories', $categoryIds);
            $wizardPrompt->update();
        }
    }

    public static function activeAllPromptsByIds($Ids)
    {
        foreach ($Ids as $id) {
            $wizardPrompt = new WizardPrompt((int) $id);
            $wizardPrompt->is_active = 1;
            $wizardPrompt->update();
        }
    }

    public static function desactiveAllPromptsByIds($Ids)
    {
        foreach ($Ids as $id) {
            $wizardPrompt = new WizardPrompt((int) $id);
            $wizardPrompt->is_active = 0;
            $wizardPrompt->update();
        }
    }

    /**
     * Delete selected prompts by Ids
     */
    public static function deletePromptsByIds($Ids)
    {
        foreach ($Ids as $id) {
            $wizardPrompt = new WizardPrompt((int) $id);
            $wizardPrompt->delete();
        }
    }

    public function getContent()
    {
        return json_decode($this->content);
    }

    public static function getFormattedPromptsForTableList($params)
    {
        $prompts = self::getPrompts();
        $formattedPrompts = [];

        foreach ($prompts as $prompt) {
            $formattedPrompts[] = [
                'id' => $prompt->id,
                'name' => $prompt->name,
                'character' => [
                    'avatar' => $prompt->character->getImageIfExist($prompt->character->name, $prompt->character->function), // Assurez-vous que cette propriété contient l'URL de l'image
                    'name' => $prompt->character->name . '  ' . $prompt->character->function,
                ],
                'target' => ucfirst($prompt->field) . ' in ' . ucfirst($prompt->entity),
                'is_active' => [
                    'href' => WizardUI::generateActionUrl($prompt->id, $params['adminLink'], $params['tokens'], 'togglePrompt'),
                    'is_active' => $prompt->is_active,
                    'text' => $prompt->is_active ? 'Active' : 'Inactive',
                    'class' => $prompt->is_active ? 'badge-success' : 'badge-danger',
                ],
                'is_default' => $prompt->is_default,
            ];
        }

        return $formattedPrompts;
    }

    /**
     * get Character Object by id
     */
    public function getCharacter()
    {
        return new WizardCharacter($this->id_character);
    }

    /**
     * return character content
     *
     * @return void
     */
    public function getChatbotSystem()
    {
        return $this->getCharacter()->content;
    }

    /**
     * Vérifie si la table wizard_prompts est vide.
     *
     * @return bool renvoie true si la table est vide, false autrement
     */
    public static function isEmpty()
    {
        $sql = new \DbQuery();
        $sql->select('COUNT(*)');
        $sql->from(static::$definition['table']);
        $count = (int) \Db::getInstance()->getValue($sql);

        return $count === 0;
    }
}
